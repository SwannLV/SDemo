{"ts":1351831700041,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":true,"ts":1351831707778,"patch":[[{"diffs":[[1,"/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.BloomPass = function ( strength, kernelSize, sigma, resolution ) {\r\n\r\n    strength = ( strength !== undefined ) ? strength : 1;\r\n\tkernelSize = ( kernelSize !== undefined ) ? kernelSize : 25;\r\n\tsigma = ( sigma !== undefined ) ? sigma : 4.0;\r\n\tresolution = ( resolution !== undefined ) ? resolution : 256;\r\n\r\n\t// render targets\r\n\r\n\tvar pars = { minFilter: THREE.LinearFilter, magFilter: THREE.LinearFilter, format: THREE.RGBFormat };\r\n\r\n\tthis.renderTargetX = new THREE.WebGLRenderTarget( resolution, resolution, pars );\r\n\tthis.renderTargetY = new THREE.WebGLRenderTarget( resolution, resolution, pars );\r\n\r\n\t// copy material\r\n\r\n\tif ( THREE.CopyShader === undefined )\r\n\t\tconsole.error( \"THREE.BloomPass relies on THREE.CopyShader\" );\r\n\r\n\tvar copyShader = THREE.CopyShader;\r\n\r\n\tthis.copyUniforms = THREE.UniformsUtils.clone( copyShader.uniforms );\r\n\r\n\tthis.copyUniforms[ \"opacity\" ].value = strength;\r\n\r\n\tthis.materialCopy = new THREE.ShaderMaterial( {\r\n\r\n\t\tuniforms: this.copyUniforms,\r\n\t\tvertexShader: copyShader.vertexShader,\r\n\t\tfragmentShader: copyShader.fragmentShader,\r\n\t\tblending: THREE.AdditiveBlending,\r\n\t\ttransparent: true\r\n\r\n\t} );\r\n\r\n\t// convolution material\r\n\r\n\tif ( THREE.ConvolutionShader === undefined )\r\n\t\tconsole.error( \"THREE.BloomPass relies on THREE.ConvolutionShader\" );\r\n\r\n\tvar convolutionShader = THREE.ConvolutionShader;\r\n\r\n\tthis.convolutionUniforms = THREE.UniformsUtils.clone( convolutionShader.uniforms );\r\n\r\n\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = THREE.BloomPass.blurx;\r\n\tthis.convolutionUniforms[ \"cKernel\" ].value = THREE.ConvolutionShader.buildKernel( sigma );\r\n\r\n\tthis.materialConvolution = new THREE.ShaderMaterial( {\r\n\r\n\t\tuniforms: this.convolutionUniforms,\r\n\t\tvertexShader:  convolutionShader.vertexShader,\r\n\t\tfragmentShader: convolutionShader.fragmentShader,\r\n\t\tdefines: {\r\n\t\t\t\"KERNEL_SIZE_FLOAT\": kernelSize.toFixed( 1 ),\r\n\t\t\t\"KERNEL_SIZE_INT\": kernelSize.toFixed( 0 )\r\n\t\t}\r\n\r\n\t} );\r\n\r\n\tthis.enabled = true;\r\n\tthis.needsSwap = false;\r\n\tthis.clear = false;\r\n\r\n};\r\n\r\nTHREE.BloomPass.prototype = {\r\n\r\n\trender: function ( renderer, writeBuffer, readBuffer, delta, maskActive ) {\r\n\r\n\t\tif ( maskActive ) renderer.context.disable( renderer.context.STENCIL_TEST );\r\n\r\n\t\t// Render quad with blured scene into texture (convolution pass 1)\r\n\r\n\t\tTHREE.EffectComposer.quad.material = this.materialConvolution;\r\n\r\n\t\tthis.convolutionUniforms[ \"tDiffuse\" ].value = readBuffer;\r\n\t\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = THREE.BloomPass.blurX;\r\n\r\n\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, this.renderTargetX, true );\r\n\r\n\r\n\t\t// Render quad with blured scene into texture (convolution pass 2)\r\n\r\n\t\tthis.convolutionUniforms[ \"tDiffuse\" ].value = this.renderTargetX;\r\n\t\tthis.convolutionUniforms[ \"uImageIncrement\" ].value = THREE.BloomPass.blurY;\r\n\r\n\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, this.renderTargetY, true );\r\n\r\n\t\t// Render original scene with superimposed blur to texture\r\n\r\n\t\tTHREE.EffectComposer.quad.material = this.materialCopy;\r\n\r\n\t\tthis.copyUniforms[ \"tDiffuse\" ].value = this.renderTargetY;\r\n\r\n\t\tif ( maskActive ) renderer.context.enable( renderer.context.STENCIL_TEST );\r\n\r\n\t\trenderer.render( THREE.EffectComposer.scene, THREE.EffectComposer.camera, readBuffer, this.clear );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.BloomPass.blurX = new THREE.Vector2( 0.001953125, 0.0 );\r\nTHREE.BloomPass.blurY = new THREE.Vector2( 0.0, 0.001953125 );\r\n "]],"start1":0,"start2":0,"length1":0,"length2":3517}]],"length":3517,"saved":false}
