{"ts":1351831960388,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":true,"ts":1351831981383,"patch":[[{"diffs":[[1,"/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * Convolution shader\r\n * ported from o3d sample to WebGL / GLSL\r\n * http://o3d.googlecode.com/svn/trunk/samples/convolution.html\r\n */\r\n\r\nTHREE.ConvolutionShader = {\r\n\r\n    defines: {\r\n\r\n\t\t\"KERNEL_SIZE_FLOAT\": \"25.0\",\r\n\t\t\"KERNEL_SIZE_INT\": \"25\",\r\n\r\n\t},\r\n\r\n\tuniforms: {\r\n\r\n\t\t\"tDiffuse\":        { type: \"t\", value: null },\r\n\t\t\"uImageIncrement\": { type: \"v2\", value: new THREE.Vector2( 0.001953125, 0.0 ) },\r\n\t\t\"cKernel\":         { type: \"fv1\", value: [] }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"uniform vec2 uImageIncrement;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t\"uniform float cKernel[ KERNEL_SIZE_INT ];\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\t\t\"uniform vec2 uImageIncrement;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vec2 imageCoord = vUv;\",\r\n\t\t\t\"vec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\",\r\n\r\n\t\t\t\"for( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\",\r\n\r\n\t\t\t\t\"sum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\",\r\n\t\t\t\t\"imageCoord += uImageIncrement;\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"gl_FragColor = sum;\",\r\n\r\n\t\t\"}\"\r\n\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tbuildKernel: function ( sigma ) {\r\n\r\n\t\t// We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.\r\n\r\n\t\tfunction gauss( x, sigma ) {\r\n\r\n\t\t\treturn Math.exp( - ( x * x ) / ( 2.0 * sigma * sigma ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar i, values, sum, halfWidth, kMaxKernelSize = 25, kernelSize = 2 * Math.ceil( sigma * 3.0 ) + 1;\r\n\r\n\t\tif ( kernelSize > kMaxKernelSize ) kernelSize = kMaxKernelSize;\r\n\t\thalfWidth = ( kernelSize - 1 ) * 0.5;\r\n\r\n\t\tvalues = new Array( kernelSize );\r\n\t\tsum = 0.0;\r\n\t\tfor ( i = 0; i < kernelSize; ++i ) {\r\n\r\n\t\t\tvalues[ i ] = gauss( i - halfWidth, sigma );\r\n\t\t\tsum += values[ i ];\r\n\r\n\t\t}\r\n\r\n\t\t// normalize the kernel\r\n\r\n\t\tfor ( i = 0; i < kernelSize; ++i ) values[ i ] /= sum;\r\n\r\n\t\treturn values;\r\n\r\n\t}\r\n\r\n};\r\n"]],"start1":0,"start2":0,"length1":0,"length2":2053}]],"length":2053,"saved":false}
