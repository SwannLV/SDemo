{"ts":1351832053339,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":true,"ts":1351832061009,"patch":[[{"diffs":[[1,"/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * Film grain & scanlines shader\r\n *\r\n * - ported from HLSL to WebGL / GLSL\r\n * http://www.truevision3d.com/forums/showcase/staticnoise_colorblackwhite_scanline_shaders-t18698.0.html\r\n *\r\n * Screen Space Static Postprocessor\r\n *\r\n * Produces an analogue noise overlay similar to a film grain / TV static\r\n *\r\n * Original implementation and noise algorithm\r\n * Pat 'Hawthorne' Shearon\r\n *\r\n * Optimized scanlines + noise version with intensity scaling\r\n * Georg 'Leviathan' Steinrohder\r\n *\r\n * This version is provided under a Creative Commons Attribution 3.0 License\r\n * http://creativecommons.org/licenses/by/3.0/\r\n */\r\n\r\nTHREE.FilmShader = {\r\n\r\n    uniforms: {\r\n\r\n\t\t\"tDiffuse\":   { type: \"t\", value: null },\r\n\t\t\"time\":       { type: \"f\", value: 0.0 },\r\n\t\t\"nIntensity\": { type: \"f\", value: 0.5 },\r\n\t\t\"sIntensity\": { type: \"f\", value: 0.05 },\r\n\t\t\"sCount\":     { type: \"f\", value: 4096 },\r\n\t\t\"grayscale\":  { type: \"i\", value: 1 }\r\n\r\n\t},\r\n\r\n\tvertexShader: [\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t\"vUv = uv;\",\r\n\t\t\t\"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join(\"\\n\"),\r\n\r\n\tfragmentShader: [\r\n\r\n\t\t// control parameter\r\n\t\t\"uniform float time;\",\r\n\r\n\t\t\"uniform bool grayscale;\",\r\n\r\n\t\t// noise effect intensity value (0 = no effect, 1 = full effect)\r\n\t\t\"uniform float nIntensity;\",\r\n\r\n\t\t// scanlines effect intensity value (0 = no effect, 1 = full effect)\r\n\t\t\"uniform float sIntensity;\",\r\n\r\n\t\t// scanlines effect count value (0 = no effect, 4096 = full effect)\r\n\t\t\"uniform float sCount;\",\r\n\r\n\t\t\"uniform sampler2D tDiffuse;\",\r\n\r\n\t\t\"varying vec2 vUv;\",\r\n\r\n\t\t\"void main() {\",\r\n\r\n\t\t\t// sample the source\r\n\t\t\t\"vec4 cTextureScreen = texture2D( tDiffuse, vUv );\",\r\n\r\n\t\t\t// make some noise\r\n\t\t\t\"float x = vUv.x * vUv.y * time *  1000.0;\",\r\n\t\t\t\"x = mod( x, 13.0 ) * mod( x, 123.0 );\",\r\n\t\t\t\"float dx = mod( x, 0.01 );\",\r\n\r\n\t\t\t// add noise\r\n\t\t\t\"vec3 cResult = cTextureScreen.rgb + cTextureScreen.rgb * clamp( 0.1 + dx * 100.0, 0.0, 1.0 );\",\r\n\r\n\t\t\t// get us a sine and cosine\r\n\t\t\t\"vec2 sc = vec2( sin( vUv.y * sCount ), cos( vUv.y * sCount ) );\",\r\n\r\n\t\t\t// add scanlines\r\n\t\t\t\"cResult += cTextureScreen.rgb * vec3( sc.x, sc.y, sc.x ) * sIntensity;\",\r\n\r\n\t\t\t// interpolate between source and result by intensity\r\n\t\t\t\"cResult = cTextureScreen.rgb + clamp( nIntensity, 0.0,1.0 ) * ( cResult - cTextureScreen.rgb );\",\r\n\r\n\t\t\t// convert to grayscale if desired\r\n\t\t\t\"if( grayscale ) {\",\r\n\r\n\t\t\t\t\"cResult = vec3( cResult.r * 0.3 + cResult.g * 0.59 + cResult.b * 0.11 );\",\r\n\r\n\t\t\t\"}\",\r\n\r\n\t\t\t\"gl_FragColor =  vec4( cResult, cTextureScreen.a );\",\r\n\r\n\t\t\"}\"\r\n\r\n\t].join(\"\\n\")\r\n\r\n};\r\n"]],"start1":0,"start2":0,"length1":0,"length2":2667}]],"length":2667,"saved":false}
