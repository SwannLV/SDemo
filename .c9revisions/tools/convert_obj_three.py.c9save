{"ts":1350874611639,"silentsave":true,"restoring":false,"patch":[[]],"length":0}
{"contributors":[],"silentsave":true,"ts":1350874672991,"patch":[[{"diffs":[[1,"\"\"\"Convert Wavefront OBJ / MTL files into Three.js (JSON model version, to be used with ascii / binary loader)\r\n\r\n-------------------------\r\nHow to use this converter\r\n-------------------------\r\n\r\npython convert_obj_three.py -i infile.obj -o outfile.js [-m \"morphfiles*.obj\"] [-c \"morphcolors*.obj\"] [-a center|centerxz|top|bottom|none] [-s smooth|flat] [-t ascii|binary] [-d invert|normal] [-b] [-e]\r\n\r\nNotes:\r\n    - flags\r\n        -i infile.obj    \t\tinput OBJ file\r\n        -o outfile.js\t\t\toutput JS file\r\n        -m \"morphfiles*.obj\"\tmorph OBJ files (can use wildcards, enclosed in quotes multiple patterns separate by space)\r\n        -c \"morphcolors*.obj\"\tmorph colors OBJ files (can use wildcards, enclosed in quotes multiple patterns separate by space)\r\n        -a center|centerxz|top|bottom|none model alignment\r\n        -s smooth|flat\t\t\tsmooth = export vertex normals, flat = no normals (face normals computed in loader)\r\n        -t ascii|binary\t\t\texport ascii or binary format (ascii has more features, binary just supports vertices, faces, normals, uvs and materials)\r\n        -d invert|normal\t\tinvert transparency\r\n        -b\t\t\t\t\t\tbake material colors into face colors\r\n        -x 10.0                 scale and truncate\r\n        -f 2                    morph frame sampling step\r\n\r\n    - by default:\r\n        use smooth shading (if there were vertex normals in the original model)\r\n        will be in ASCII format\r\n        original model is assumed to use non-inverted transparency / dissolve (0.0 fully transparent, 1.0 fully opaque)\r\n        no face colors baking\r\n        no scale and truncate\r\n        morph frame step = 1 (all files will be processed)\r\n\r\n    - binary conversion will create two files:\r\n        outfile.js  (materials)\r\n        outfile.bin (binary buffers)\r\n\r\n--------------------------------------------------\r\nHow to use generated JS file in your HTML document\r\n--------------------------------------------------\r\n\r\n    <script type=\"text/javascript\" src=\"Three.js\"></script>\r\n\r\n    ...\r\n\r\n    <script type=\"text/javascript\">\r\n        ...\r\n\r\n        // load ascii model\r\n\r\n        var jsonLoader = new THREE.JSONLoader();\r\n        jsonLoader.load( \"Model_ascii.js\", function( geometry ) { createScene( geometry ) } );\r\n\r\n        // load binary model\r\n\r\n        var binLoader = new THREE.BinaryLoader();\r\n        binLoader.load( \"Model_bin.js\", function( geometry ) { createScene( geometry) } );\r\n\r\n        function createScene( geometry ) {\r\n\r\n            var mesh = new THREE.Mesh( geometry, new THREE.MeshFaceMaterial() );\r\n\r\n        }\r\n\r\n        ...\r\n    </script>\r\n\r\n-------------------------------------\r\nParsers based on formats descriptions\r\n-------------------------------------\r\n\r\n    http://en.wikipedia.org/wiki/Obj\r\n    http://en.wikipedia.org/wiki/Material_Template_Library\r\n\r\n-------------------\r\nCurrent limitations\r\n-------------------\r\n\r\n    - for the moment, only diffuse color and texture are used\r\n      (will need to extend shaders / renderers / materials in Three)\r\n\r\n    - texture coordinates can be wrong in canvas renderer\r\n      (there is crude normalization, but it doesn't\r\n       work for all cases)\r\n\r\n    - smoothing can be turned on/off only for the whole mesh\r\n\r\n----------------------------------------------\r\nHow to get proper OBJ + MTL files with Blender\r\n----------------------------------------------\r\n\r\n    0. Remove default cube (press DEL and ENTER)\r\n\r\n    1. Import / create model\r\n\r\n    2. Select all meshes (Select -> Select All by Type -> Mesh)\r\n\r\n    3. Export to OBJ (File -> Export -> Wavefront .obj)\r\n        - enable following options in exporter\r\n            Material Groups\r\n            Rotate X90\r\n            Apply Modifiers\r\n            High Quality Normals\r\n            Copy Images\r\n            Selection Only\r\n            Objects as OBJ Objects\r\n            UVs\r\n            Normals\r\n            Materials\r\n\r\n        - select empty folder\r\n        - give your exported file name with \"obj\" extension\r\n        - click on \"Export OBJ\" button\r\n\r\n    4. Your model is now all files in this folder (OBJ, MTL, number of images)\r\n        - this converter assumes all files staying in the same folder,\r\n          (OBJ / MTL files use relative paths)\r\n\r\n        - for WebGL, textures must be power of 2 sized\r\n\r\n------\r\nAuthor\r\n------\r\nAlteredQualia http://alteredqualia.com\r\n\r\n\"\"\"\r\n\r\nimport fileinput\r\nimport operator\r\nimport random\r\nimport os.path\r\nimport getopt\r\nimport sys\r\nimport struct\r\nimport math\r\nimport glob\r\n\r\n# #####################################################\r\n# Configuration\r\n# #####################################################\r\nALIGN = \"none\"        \t# center centerxz bottom top none\r\nSHADING = \"smooth\"      # smooth flat\r\nTYPE = \"ascii\"          # ascii binary\r\nTRANSPARENCY = \"normal\" # normal invert\r\n\r\nTRUNCATE = False\r\nSCALE = 1.0\r\n\r\nFRAMESTEP = 1\r\n\r\nBAKE_COLORS = False\r\n\r\n# default colors for debugging (each material gets one distinct color):\r\n# white, red, green, blue, yellow, cyan, magenta\r\nCOLORS = [0xeeeeee, 0xee0000, 0x00ee00, 0x0000ee, 0xeeee00, 0x00eeee, 0xee00ee]\r\n\r\n# #####################################################\r\n# Templates\r\n# #####################################################\r\nTEMPLATE_FILE_ASCII = u\"\"\"\\\r\n{\r\n\r\n    \"metadata\" :\r\n    {\r\n        \"formatVersion\" : 3.1,\r\n        \"sourceFile\"    : \"%(fname)s\",\r\n        \"generatedBy\"   : \"OBJConverter\",\r\n        \"vertices\"      : %(nvertex)d,\r\n        \"faces\"         : %(nface)d,\r\n        \"normals\"       : %(nnormal)d,\r\n        \"colors\"        : %(ncolor)d,\r\n        \"uvs\"           : %(nuv)d,\r\n        \"materials\"     : %(nmaterial)d\r\n    },\r\n\r\n    \"scale\" : %(scale)f,\r\n\r\n    \"materials\": [%(materials)s],\r\n\r\n    \"vertices\": [%(vertices)s],\r\n\r\n    \"morphTargets\": [%(morphTargets)s],\r\n\r\n    \"morphColors\": [%(morphColors)s],\r\n\r\n    \"normals\": [%(normals)s],\r\n\r\n    \"colors\": [%(colors)s],\r\n\r\n    \"uvs\": [[%(uvs)s]],\r\n\r\n    \"faces\": [%(faces)s]\r\n\r\n}\r\n\"\"\"\r\n\r\nTEMPLATE_FILE_BIN = u\"\"\"\\\r\n{\r\n\r\n    \"metadata\" :\r\n    {\r\n        \"formatVersion\" : 3.1,\r\n        \"sourceFile\"    : \"%(fname)s\",\r\n        \"generatedBy\"   : \"OBJConverter\",\r\n        \"vertices\"      : %(nvertex)d,\r\n        \"faces\"         : %(nface)d,\r\n        \"normals\"       : %(nnormal)d,\r\n        \"uvs\"           : %(nuv)d,\r\n        \"materials\"     : %(nmaterial)d\r\n    },\r\n\r\n    \"materials\": [%(materials)s],\r\n\r\n    \"buffers\": \"%(buffers)s\"\r\n\r\n}\r\n\"\"\"\r\n\r\nTEMPLATE_VERTEX = \"%f,%f,%f\"\r\nTEMPLATE_VERTEX_TRUNCATE = \"%d,%d,%d\"\r\n\r\nTEMPLATE_N = \"%.5g,%.5g,%.5g\"\r\nTEMPLATE_UV = \"%.5g,%.5g\"\r\nTEMPLATE_COLOR = \"%.3g,%.3g,%.3g\"\r\nTEMPLATE_COLOR_DEC = \"%d\"\r\n\r\nTEMPLATE_MORPH_VERTICES = '\\t{ \"name\": \"%s\", \"vertices\": [%s] }'\r\nTEMPLATE_MORPH_COLORS   = '\\t{ \"name\": \"%s\", \"colors\": [%s] }'\r\n\r\n# #####################################################\r\n# Utils\r\n# #####################################################\r\ndef file_exists(filename):\r\n    \"\"\"Return true if file exists and is accessible for reading.\r\n\r\n    Should be safer than just testing for existence due to links and\r\n    permissions magic on Unix filesystems.\r\n\r\n    @rtype: boolean\r\n    \"\"\"\r\n\r\n    try:\r\n        f = open(filename, 'r')\r\n        f.close()\r\n        return True\r\n    except IOError:\r\n        return False\r\n\r\n\r\ndef get_name(fname):\r\n    \"\"\"Create model name based of filename (\"path/fname.js\" -> \"fname\").\r\n    \"\"\"\r\n\r\n    return os.path.splitext(os.path.basename(fname))[0]\r\n\r\ndef bbox(vertices):\r\n    \"\"\"Compute bounding box of vertex array.\r\n    \"\"\"\r\n\r\n    if len(vertices)>0:\r\n        minx = maxx = vertices[0][0]\r\n        miny = maxy = vertices[0][1]\r\n        minz = maxz = vertices[0][2]\r\n\r\n        for v in vertices[1:]:\r\n            if v[0]<minx:\r\n                minx = v[0]\r\n            elif v[0]>maxx:\r\n                maxx = v[0]\r\n\r\n            if v[1]<miny:\r\n                miny = v[1]\r\n            elif v[1]>maxy:\r\n                maxy = v[1]\r\n\r\n            if v[2]<minz:\r\n                minz = v[2]\r\n            elif v[2]>maxz:\r\n                maxz = v[2]\r\n\r\n        return { 'x':[minx,maxx], 'y':[miny,maxy], 'z':[minz,maxz] }\r\n\r\n    else:\r\n        return { 'x':[0,0], 'y':[0,0], 'z':[0,0] }\r\n\r\ndef translate(vertices, t):\r\n    \"\"\"Translate array of vertices by vector t.\r\n    \"\"\"\r\n\r\n    for i in xrange(len(vertices)):\r\n        vertices[i][0] += t[0]\r\n        vertices[i][1] += t[1]\r\n        vertices[i][2] += t[2]\r\n\r\ndef center(vertices):\r\n    \"\"\"Center model (middle of bounding box).\r\n    \"\"\"\r\n\r\n    bb = bbox(vertices)\r\n\r\n    cx = bb['x'][0] + (bb['x'][1] - bb['x'][0])/2.0\r\n    cy = bb['y'][0] + (bb['y'][1] - bb['y'][0])/2.0\r\n    cz = bb['z'][0] + (bb['z'][1] - bb['z'][0])/2.0\r\n\r\n    translate(vertices, [-cx,-cy,-cz])\r\n\r\ndef top(vertices):\r\n    \"\"\"Align top of the model with the floor (Y-axis) and center it around X and Z.\r\n    \"\"\"\r\n\r\n    bb = bbox(vertices)\r\n\r\n    cx = bb['x'][0] + (bb['x'][1] - bb['x'][0])/2.0\r\n    cy = bb['y'][1]\r\n    cz = bb['z'][0] + (bb['z'][1] - bb['z'][0])/2.0\r\n\r\n    translate(vertices, [-cx,-cy,-cz])\r\n\r\ndef bottom(vertices):\r\n    \"\"\"Align bottom of the model with the floor (Y-axis) and center it around X and Z.\r\n    \"\"\"\r\n\r\n    bb = bbox(vertices)\r\n\r\n    cx = bb['x'][0] + (bb['x'][1] - bb['x'][0])/2.0\r\n    cy = bb['y'][0]\r\n    cz = bb['z'][0] + (bb['z'][1] - bb['z'][0])/2.0\r\n\r\n    translate(vertices, [-cx,-cy,-cz])\r\n\r\ndef centerxz(vertices):\r\n    \"\"\"Center model around X and Z.\r\n    \"\"\"\r\n\r\n    bb = bbox(vertices)\r\n\r\n    cx = bb['x'][0] + (bb['x'][1] - bb['x'][0])/2.0\r\n    cy = 0\r\n    cz = bb['z'][0] + (bb['z'][1] - bb['z'][0])/2.0\r\n\r\n    translate(vertices, [-cx,-cy,-cz])\r\n\r\ndef normalize(v):\r\n    \"\"\"Normalize 3d vector\"\"\"\r\n\r\n    l = math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2])\r\n    if l:\r\n        v[0] /= l\r\n        v[1] /= l\r\n        v[2] /= l\r\n\r\ndef veckey3(v):\r\n    return round(v[0], 6), round(v[1], 6), round(v[2], 6)\r\n\r\n# #####################################################\r\n# MTL parser\r\n# #####################################################\r\ndef texture_relative_path(fullpath):\r\n    texture_file = os.path.basename(fullpath.replace(\"\\\\\", \"/\"))\r\n    return texture_file\r\n\r\ndef parse_mtl(fname):\r\n    \"\"\"Parse MTL file.\r\n    \"\"\"\r\n\r\n    materials = {}\r\n\r\n    for line in fileinput.input(fname):\r\n        chunks = line.split()\r\n        if len(chunks) > 0:\r\n\r\n            # Material start\r\n            # newmtl identifier\r\n            if chunks[0] == \"newmtl\":\r\n                if len(chunks) > 1:\r\n                    identifier = chunks[1]\r\n                else:\r\n                    identifier = \"\"\r\n                if not identifier in materials:\r\n                    materials[identifier] = {}\r\n\r\n            # Diffuse color\r\n            # Kd 1.000 1.000 1.000\r\n            if chunks[0] == \"Kd\" and len(chunks) == 4:\r\n                materials[identifier][\"colorDiffuse\"] = [float(chunks[1]), float(chunks[2]), float(chunks[3])]\r\n\r\n            # Ambient color\r\n            # Ka 1.000 1.000 1.000\r\n            if chunks[0] == \"Ka\" and len(chunks) == 4:\r\n                materials[identifier][\"colorAmbient\"] = [float(chunks[1]), float(chunks[2]), float(chunks[3])]\r\n\r\n            # Specular color\r\n            # Ks 1.000 1.000 1.000\r\n            if chunks[0] == \"Ks\" and len(chunks) == 4:\r\n                materials[identifier][\"colorSpecular\"] = [float(chunks[1]), float(chunks[2]), float(chunks[3])]\r\n\r\n            # Specular coefficient\r\n            # Ns 154.000\r\n            if chunks[0] == \"Ns\" and len(chunks) == 2:\r\n                materials[identifier][\"specularCoef\"] = float(chunks[1])\r\n\r\n            # Transparency\r\n            # Tr 0.9 or d 0.9\r\n            if (chunks[0] == \"Tr\" or chunks[0] == \"d\") and len(chunks) == 2:\r\n                if TRANSPARENCY == \"invert\":\r\n                    materials[identifier][\"transparency\"] = 1.0 - float(chunks[1])\r\n                else:\r\n                    materials[identifier][\"transparency\"] = float(chunks[1])\r\n\r\n            # Optical density\r\n            # Ni 1.0\r\n            if chunks[0] == \"Ni\" and len(chunks) == 2:\r\n                materials[identifier][\"opticalDensity\"] = float(chunks[1])\r\n\r\n            # Diffuse texture\r\n            # map_Kd texture_diffuse.jpg\r\n            if chunks[0] == \"map_Kd\" and len(chunks) == 2:\r\n                materials[identifier][\"mapDiffuse\"] = texture_relative_path(chunks[1])\r\n\r\n            # Ambient texture\r\n            # map_Ka texture_ambient.jpg\r\n            if chunks[0] == \"map_Ka\" and len(chunks) == 2:\r\n                materials[identifier][\"mapAmbient\"] = texture_relative_path(chunks[1])\r\n\r\n            # Specular texture\r\n            # map_Ks texture_specular.jpg\r\n            if chunks[0] == \"map_Ks\" and len(chunks) == 2:\r\n                materials[identifier][\"mapSpecular\"] = texture_relative_path(chunks[1])\r\n\r\n            # Alpha texture\r\n            # map_d texture_alpha.png\r\n            if chunks[0] == \"map_d\" and len(chunks) == 2:\r\n                materials[identifier][\"mapAlpha\"] = texture_relative_path(chunks[1])\r\n\r\n            # Bump texture\r\n            # map_bump texture_bump.jpg or bump texture_bump.jpg\r\n            if (chunks[0] == \"map_bump\" or chunks[0] == \"bump\") and len(chunks) == 2:\r\n                materials[identifier][\"mapBump\"] = texture_relative_path(chunks[1])\r\n\r\n            # Illumination\r\n            # illum 2\r\n            #\r\n            # 0. Color on and Ambient off\r\n            # 1. Color on and Ambient on\r\n            # 2. Highlight on\r\n            # 3. Reflection on and Ray trace on\r\n            # 4. Transparency: Glass on, Reflection: Ray trace on\r\n            # 5. Reflection: Fresnel on and Ray trace on\r\n            # 6. Transparency: Refraction on, Reflection: Fresnel off and Ray trace on\r\n            # 7. Transparency: Refraction on, Reflection: Fresnel on and Ray trace on\r\n            # 8. Reflection on and Ray trace off\r\n            # 9. Transparency: Glass on, Reflection: Ray trace off\r\n            # 10. Casts shadows onto invisible surfaces\r\n            if chunks[0] == \"illum\" and len(chunks) == 2:\r\n                materials[identifier][\"illumination\"] = int(chunks[1])\r\n\r\n    return materials\r\n\r\n# #####################################################\r\n# OBJ parser\r\n# #####################################################\r\ndef parse_vertex(text):\r\n    \"\"\"Parse text chunk specifying single vertex.\r\n\r\n    Possible formats:\r\n        vertex index\r\n        vertex index / texture index\r\n        vertex index / texture index / normal index\r\n        vertex index / / normal index\r\n    \"\"\"\r\n\r\n    v = 0\r\n    t = 0\r\n    n = 0\r\n\r\n    chunks = text.split(\"/\")\r\n\r\n    v = int(chunks[0])\r\n    if len(chunks) > 1:\r\n        if chunks[1]:\r\n            t = int(chunks[1])\r\n    if len(chunks) > 2:\r\n        if chunks[2]:\r\n            n = int(chunks[2])\r\n\r\n    return { 'v':v, 't':t, 'n':n }\r\n\r\ndef parse_obj(fname):\r\n    \"\"\"Parse OBJ file.\r\n    \"\"\"\r\n\r\n    vertices = []\r\n    normals = []\r\n    uvs = []\r\n\r\n    faces = []\r\n\r\n    materials = {}\r\n    material = \"\"\r\n    mcounter = 0\r\n    mcurrent = 0\r\n\r\n    mtllib = \"\"\r\n\r\n    # current face state\r\n    group = 0\r\n    object = 0\r\n    smooth = 0\r\n\r\n    for line in fileinput.input(fname):\r\n        chunks = line.split()\r\n        if len(chunks) > 0:\r\n\r\n            # Vertices as (x,y,z) coordinates\r\n            # v 0.123 0.234 0.345\r\n            if chunks[0] == \"v\" and len(chunks) == 4:\r\n                x = float(chunks[1])\r\n                y = float(chunks[2])\r\n                z = float(chunks[3])\r\n                vertices.append([x,y,z])\r\n\r\n            # Normals in (x,y,z) form; normals might not be unit\r\n            # vn 0.707 0.000 0.707\r\n            if chunks[0] == \"vn\" and len(chunks) == 4:\r\n                x = float(chunks[1])\r\n                y = float(chunks[2])\r\n                z = float(chunks[3])\r\n                normals.append([x,y,z])\r\n\r\n            # Texture coordinates in (u,v[,w]) coordinates, w is optional\r\n            # vt 0.500 -1.352 [0.234]\r\n            if chunks[0] == \"vt\" and len(chunks) >= 3:\r\n                u = float(chunks[1])\r\n                v = float(chunks[2])\r\n                w = 0\r\n                if len(chunks)>3:\r\n                    w = float(chunks[3])\r\n                uvs.append([u,v,w])\r\n\r\n            # Face\r\n            if chunks[0] == \"f\" and len(chunks) >= 4:\r\n                vertex_index = []\r\n                uv_index = []\r\n                normal_index = []\r\n\r\n\r\n                # Precompute vert / normal / uv lists\r\n                # for negative index lookup\r\n                vertlen = len(vertices) + 1\r\n                normlen = len(normals) + 1\r\n                uvlen = len(uvs) + 1\r\n\r\n                for v in chunks[1:]:\r\n                    vertex = parse_vertex(v)\r\n                    if vertex['v']:\r\n                        if vertex['v'] < 0:\r\n                            vertex['v'] += vertlen\r\n                        vertex_index.append(vertex['v'])\r\n                    if vertex['t']:\r\n                        if vertex['t'] < 0:\r\n                            vertex['t'] += uvlen\r\n                        uv_index.append(vertex['t'])\r\n                    if vertex['n']:\r\n                        if vertex['n'] < 0:\r\n                            vertex['n'] += normlen\r\n                        normal_index.append(vertex['n'])\r\n                faces.append({\r\n                    'vertex':vertex_index,\r\n                    'uv':uv_index,\r\n                    'normal':normal_index,\r\n\r\n                    'material':mcurrent,\r\n                    'group':group,\r\n                    'object':object,\r\n                    'smooth':smooth,\r\n                    })\r\n\r\n            # Group\r\n            if chunks[0] == \"g\" and len(chunks) == 2:\r\n                group = chunks[1]\r\n\r\n            # Object\r\n            if chunks[0] == \"o\" and len(chunks) == 2:\r\n                object = chunks[1]\r\n\r\n            # Materials definition\r\n            if chunks[0] == \"mtllib\" and len(chunks) == 2:\r\n                mtllib = chunks[1]\r\n\r\n            # Material\r\n            if chunks[0] == \"usemtl\":\r\n                if len(chunks) > 1:\r\n                    material = chunks[1]\r\n                else:\r\n                    material = \"\"\r\n                if not material in materials:\r\n                    mcurrent = mcounter\r\n                    materials[material] = mcounter\r\n                    mcounter += 1\r\n                else:\r\n                    mcurrent = materials[material]\r\n\r\n            # Smooth shading\r\n            if chunks[0] == \"s\" and len(chunks) == 2:\r\n                smooth = chunks[1]\r\n\r\n    return faces, vertices, uvs, normals, materials, mtllib\r\n\r\n# #####################################################\r\n# Generator - faces\r\n# #####################################################\r\ndef setBit(value, position, on):\r\n    if on:\r\n        mask = 1 << position\r\n        return (value | mask)\r\n    else:\r\n        mask = ~(1 << position)\r\n        return (value & mask)\r\n\r\ndef generate_face(f, fc):\r\n    isTriangle = ( len(f['vertex']) == 3 )\r\n\r\n    if isTriangle:\r\n        nVertices = 3\r\n    else:\r\n        nVertices = 4\r\n\r\n    hasMaterial = True # for the moment OBJs without materials get default material\r\n\r\n    hasFaceUvs = False # not supported in OBJ\r\n    hasFaceVertexUvs = ( len(f['uv']) >= nVertices )\r\n\r\n    hasFaceNormals = False # don't export any face normals (as they are computed in engine)\r\n    hasFaceVertexNormals = ( len(f[\"normal\"]) >= nVertices and SHADING == \"smooth\" )\r\n\r\n    hasFaceColors = BAKE_COLORS\r\n    hasFaceVertexColors = False # not supported in OBJ\r\n\r\n    faceType = 0\r\n    faceType = setBit(faceType, 0, not isTriangle)\r\n    faceType = setBit(faceType, 1, hasMaterial)\r\n    faceType = setBit(faceType, 2, hasFaceUvs)\r\n    faceType = setBit(faceType, 3, hasFaceVertexUvs)\r\n    faceType = setBit(faceType, 4, hasFaceNormals)\r\n    faceType = setBit(faceType, 5, hasFaceVertexNormals)\r\n    faceType = setBit(faceType, 6, hasFaceColors)\r\n    faceType = setBit(faceType, 7, hasFaceVertexColors)\r\n\r\n    faceData = []\r\n\r\n    # order is important, must match order in JSONLoader\r\n\r\n    # face type\r\n    # vertex indices\r\n    # material index\r\n    # face uvs index\r\n    # face vertex uvs indices\r\n    # face normal index\r\n    # face vertex normals indices\r\n    # face color index\r\n    # face vertex colors indices\r\n\r\n    faceData.append(faceType)\r\n\r\n    # must clamp in case on polygons bigger than quads\r\n\r\n    for i in xrange(nVertices):\r\n        index = f['vertex'][i] - 1\r\n        faceData.append(index)\r\n\r\n    faceData.append( f['material'] )\r\n\r\n    if hasFaceVertexUvs:\r\n        for i in xrange(nVertices):\r\n            index = f['uv'][i] - 1\r\n            faceData.append(index)\r\n\r\n    if hasFaceVertexNormals:\r\n        for i in xrange(nVertices):\r\n            index = f['normal'][i] - 1\r\n            faceData.append(index)\r\n\r\n    if hasFaceColors:\r\n        index = fc['material']\r\n        faceData.append(index)\r\n\r\n    return \",\".join( map(str, faceData) )\r\n\r\n# #####################################################\r\n# Generator - chunks\r\n# #####################################################\r\ndef hexcolor(c):\r\n    return ( int(c[0] * 255) << 16  ) + ( int(c[1] * 255) << 8 ) + int(c[2] * 255)\r\n\r\ndef generate_vertex(v, option_vertices_truncate, scale):\r\n    if not option_vertices_truncate:\r\n        return TEMPLATE_VERTEX % (v[0], v[1], v[2])\r\n    else:\r\n        return TEMPLATE_VERTEX_TRUNCATE % (scale * v[0], scale * v[1], scale * v[2])\r\n\r\ndef generate_normal(n):\r\n    return TEMPLATE_N % (n[0], n[1], n[2])\r\n\r\ndef generate_uv(uv):\r\n    return TEMPLATE_UV % (uv[0], uv[1])\r\n\r\ndef generate_color_rgb(c):\r\n    return TEMPLATE_COLOR % (c[0], c[1], c[2])\r\n\r\ndef generate_color_decimal(c):\r\n    return TEMPLATE_COLOR_DEC % hexcolor(c)\r\n\r\n# #####################################################\r\n# Morphs\r\n# #####################################################\r\ndef generate_morph_vertex(name, vertices):\r\n    vertex_string = \",\".join(generate_vertex(v, TRUNCATE, SCALE) for v in vertices)\r\n    return TEMPLATE_MORPH_VERTICES % (name, vertex_string)\r\n\r\ndef generate_morph_color(name, colors):\r\n    color_string = \",\".join(generate_color_rgb(c) for c in colors)\r\n    return TEMPLATE_MORPH_COLORS % (name, color_string)\r\n\r\ndef extract_material_colors(materials, mtlfilename, basename):\r\n    \"\"\"Extract diffuse colors from MTL materials\r\n    \"\"\"\r\n\r\n    if not materials:\r\n        materials = { 'default': 0 }\r\n\r\n    mtl = create_materials(materials, mtlfilename, basename)\r\n\r\n    mtlColorArraySrt = []\r\n    for m in mtl:\r\n        if m in materials:\r\n            index = materials[m]\r\n            color = mtl[m].get(\"colorDiffuse\", [1,0,0])\r\n            mtlColorArraySrt.append([index, color])\r\n\r\n    mtlColorArraySrt.sort()\r\n    mtlColorArray = [x[1] for x in mtlColorArraySrt]\r\n\r\n    return mtlColorArray\r\n\r\ndef extract_face_colors(faces, material_colors):\r\n    \"\"\"Extract colors from materials and assign them to faces\r\n    \"\"\"\r\n\r\n    faceColors = []\r\n\r\n    for face in faces:\r\n        material_index = face['material']\r\n        faceColors.append(material_colors[material_index])\r\n\r\n    return faceColors\r\n\r\ndef generate_morph_targets(morphfiles, n_vertices, infile):\r\n    skipOriginalMorph = False\r\n    norminfile = os.path.normpath(infile)\r\n\r\n    morphVertexData = []\r\n\r\n    for mfilepattern in morphfiles.split():\r\n\r\n        matches = glob.glob(mfilepattern)\r\n        matches.sort()\r\n\r\n        indices = range(0, len(matches), FRAMESTEP)\r\n        for i in indices:\r\n            path = matches[i]\r\n\r\n            normpath = os.path.normpath(path)\r\n\r\n            if normpath != norminfile or not skipOriginalMorph:\r\n\r\n                name = os.path.basename(normpath)\r\n\r\n                morphFaces, morphVertices, morphUvs, morphNormals, morphMaterials, morphMtllib = parse_obj(normpath)\r\n\r\n                n_morph_vertices = len(morphVertices)\r\n\r\n                if n_vertices != n_morph_vertices:\r\n\r\n                    print \"WARNING: skipping morph [%s] with different number of vertices [%d] than the original model [%d]\" % (name, n_morph_vertices, n_vertices)\r\n\r\n                else:\r\n\r\n                    if ALIGN == \"center\":\r\n                        center(morphVertices)\r\n                    elif ALIGN == \"centerxz\":\r\n                        centerxz(morphVertices)\r\n                    elif ALIGN == \"bottom\":\r\n                        bottom(morphVertices)\r\n                    elif ALIGN == \"top\":\r\n                        top(morphVertices)\r\n\r\n                    morphVertexData.append((get_name(name), morphVertices))\r\n                    print \"adding [%s] with %d vertices\" % (name, n_morph_vertices)\r\n\r\n    morphTargets = \"\"\r\n    if len(morphVertexData):\r\n        morphTargets = \"\\n%s\\n\\t\" % \",\\n\".join(generate_morph_vertex(name, vertices) for name, vertices in morphVertexData)\r\n\r\n    return morphTargets\r\n\r\ndef generate_morph_colors(colorfiles, n_vertices, n_faces):\r\n    morphColorData = []\r\n    colorFaces = []\r\n    materialColors = []\r\n\r\n    for mfilepattern in colorfiles.split():\r\n\r\n        matches = glob.glob(mfilepattern)\r\n        matches.sort()\r\n        for path in matches:\r\n            normpath = os.path.normpath(path)\r\n            name = os.path.basename(normpath)\r\n\r\n            morphFaces, morphVertices, morphUvs, morphNormals, morphMaterials, morphMtllib = parse_obj(normpath)\r\n\r\n            n_morph_vertices = len(morphVertices)\r\n            n_morph_faces = len(morphFaces)\r\n\r\n            if n_vertices != n_morph_vertices:\r\n\r\n                print \"WARNING: skipping morph color map [%s] with different number of vertices [%d] than the original model [%d]\" % (name, n_morph_vertices, n_vertices)\r\n\r\n            elif n_faces != n_morph_faces:\r\n\r\n                print \"WARNING: skipping morph color map [%s] with different number of faces [%d] than the original model [%d]\" % (name, n_morph_faces, n_faces)\r\n\r\n            else:\r\n\r\n                morphMaterialColors = extract_material_colors(morphMaterials, morphMtllib, normpath)\r\n                morphFaceColors = extract_face_colors(morphFaces, morphMaterialColors)\r\n                morphColorData.append((get_name(name), morphFaceColors))\r\n\r\n                # take first color map for baking into face colors\r\n\r\n                if len(colorFaces) == 0:\r\n                    colorFaces = morphFaces\r\n                    materialColors = morphMaterialColors\r\n\r\n                print \"adding [%s] with %d face colors\" % (name, len(morphFaceColors))\r\n\r\n    morphColors = \"\"\r\n    if len(morphColorData):\r\n        morphColors = \"\\n%s\\n\\t\" % \",\\n\".join(generate_morph_color(name, colors) for name, colors in morphColorData)\r\n\r\n    return morphColors, colorFaces, materialColors\r\n\r\n# #####################################################\r\n# Materials\r\n# #####################################################\r\ndef generate_color(i):\r\n    \"\"\"Generate hex color corresponding to integer.\r\n\r\n    Colors should have well defined ordering.\r\n    First N colors are hardcoded, then colors are random\r\n    (must seed random number  generator with deterministic value\r\n    before getting colors).\r\n    \"\"\"\r\n\r\n    if i < len(COLORS):\r\n        #return \"0x%06x\" % COLORS[i]\r\n        return COLORS[i]\r\n    else:\r\n        #return \"0x%06x\" % int(0xffffff * random.random())\r\n        return int(0xffffff * random.random())\r\n\r\ndef value2string(v):\r\n    if type(v)==str and v[0:2] != \"0x\":\r\n        return '\"%s\"' % v\r\n    elif type(v) == bool:\r\n        return str(v).lower()\r\n    return str(v)\r\n\r\ndef generate_materials(mtl, materials):\r\n    \"\"\"Generate JS array of materials objects\r\n\r\n    JS material objects are basically prettified one-to-one\r\n    mappings of MTL properties in JSON format.\r\n    \"\"\"\r\n\r\n    mtl_array = []\r\n    for m in mtl:\r\n        if m in materials:\r\n            index = materials[m]\r\n\r\n            # add debug information\r\n            #  materials should be sorted according to how\r\n            #  they appeared in OBJ file (for the first time)\r\n            #  this index is identifier used in face definitions\r\n            mtl[m]['DbgName'] = m\r\n            mtl[m]['DbgIndex'] = index\r\n            mtl[m]['DbgColor'] = generate_color(index)\r\n\r\n            if BAKE_COLORS:\r\n                mtl[m]['vertexColors'] = \"face\"\r\n\r\n            mtl_raw = \",\\n\".join(['\\t\"%s\" : %s' % (n, value2string(v)) for n,v in sorted(mtl[m].items())])\r\n            mtl_string = \"\\t{\\n%s\\n\\t}\" % mtl_raw\r\n            mtl_array.append([index, mtl_string])\r\n\r\n    return \",\\n\\n\".join([m for i,m in sorted(mtl_array)])\r\n\r\ndef generate_mtl(materials):\r\n    \"\"\"Generate dummy materials (if there is no MTL file).\r\n    \"\"\"\r\n\r\n    mtl = {}\r\n    for m in materials:\r\n        index = materials[m]\r\n        mtl[m] = {\r\n            'DbgName': m,\r\n            'DbgIndex': index,\r\n            'DbgColor': generate_color(index)\r\n        }\r\n    return mtl\r\n\r\ndef generate_materials_string(materials, mtlfilename, basename):\r\n    \"\"\"Generate final materials string.\r\n    \"\"\"\r\n\r\n    if not materials:\r\n        materials = { 'default': 0 }\r\n\r\n    mtl = create_materials(materials, mtlfilename, basename)\r\n    return generate_materials(mtl, materials)\r\n\r\ndef create_materials(materials, mtlfilename, basename):\r\n    \"\"\"Parse MTL file and create mapping between its materials and OBJ materials.\r\n       Eventual edge cases are handled here (missing materials, missing MTL file).\r\n    \"\"\"\r\n\r\n    random.seed(42) # to get well defined color order for debug colors\r\n\r\n    # default materials with debug colors for when\r\n    # there is no specified MTL / MTL loading failed,\r\n    # or if there were no materials / null materials\r\n\r\n    mtl = generate_mtl(materials)\r\n\r\n    if mtlfilename:\r\n\r\n        # create full pathname for MTL (included from OBJ)\r\n\r\n        path = os.path.dirname(basename)\r\n        fname = os.path.join(path, mtlfilename)\r\n\r\n        if file_exists(fname):\r\n\r\n            # override default materials with real ones from MTL\r\n            # (where they exist, otherwise keep defaults)\r\n\r\n            mtl.update(parse_mtl(fname))\r\n\r\n        else:\r\n\r\n            print \"Couldn't find [%s]\" % fname\r\n\r\n    return mtl\r\n\r\n# #####################################################\r\n# Faces\r\n# #####################################################\r\ndef is_triangle_flat(f):\r\n    return len(f['vertex'])==3 and not (f[\"normal\"] and SHADING == \"smooth\") and not f['uv']\r\n\r\ndef is_triangle_flat_uv(f):\r\n    return len(f['vertex'])==3 and not (f[\"normal\"] and SHADING == \"smooth\") and len(f['uv'])==3\r\n\r\ndef is_triangle_smooth(f):\r\n    return len(f['vertex'])==3 and f[\"normal\"] and SHADING == \"smooth\" and not f['uv']\r\n\r\ndef is_triangle_smooth_uv(f):\r\n    return len(f['vertex'])==3 and f[\"normal\"] and SHADING == \"smooth\" and len(f['uv'])==3\r\n\r\ndef is_quad_flat(f):\r\n    return len(f['vertex'])==4 and not (f[\"normal\"] and SHADING == \"smooth\") and not f['uv']\r\n\r\ndef is_quad_flat_uv(f):\r\n    return len(f['vertex'])==4 and not (f[\"normal\"] and SHADING == \"smooth\") and len(f['uv'])==4\r\n\r\ndef is_quad_smooth(f):\r\n    return len(f['vertex'])==4 and f[\"normal\"] and SHADING == \"smooth\" and not f['uv']\r\n\r\ndef is_quad_smooth_uv(f):\r\n    return len(f['vertex'])==4 and f[\"normal\"] and SHADING == \"smooth\" and len(f['uv'])==4\r\n\r\ndef sort_faces(faces):\r\n    data = {\r\n    'triangles_flat': [],\r\n    'triangles_flat_uv': [],\r\n    'triangles_smooth': [],\r\n    'triangles_smooth_uv': [],\r\n\r\n    'quads_flat': [],\r\n    'quads_flat_uv': [],\r\n    'quads_smooth': [],\r\n    'quads_smooth_uv': []\r\n    }\r\n\r\n    for f in faces:\r\n        if is_triangle_flat(f):\r\n            data['triangles_flat'].append(f)\r\n        elif is_triangle_flat_uv(f):\r\n            data['triangles_flat_uv'].append(f)\r\n        elif is_triangle_smooth(f):\r\n            data['triangles_smooth'].append(f)\r\n        elif is_triangle_smooth_uv(f):\r\n            data['triangles_smooth_uv'].append(f)\r\n\r\n        elif is_quad_flat(f):\r\n            data['quads_flat'].append(f)\r\n        elif is_quad_flat_uv(f):\r\n            data['quads_flat_uv'].append(f)\r\n        elif is_quad_smooth(f):\r\n            data['quads_smooth'].append(f)\r\n        elif is_quad_smooth_uv(f):\r\n            data['quads_smooth_uv'].append(f)\r\n\r\n    return data\r\n\r\n# #####################################################\r\n# API - ASCII converter\r\n# #####################################################\r\ndef convert_ascii(infile, morphfiles, colorfiles, outfile):\r\n    \"\"\"Convert infile.obj to outfile.js\r\n\r\n    Here is where everything happens. If you need to automate conversions,\r\n    just import this file as Python module and call this method.\r\n    \"\"\"\r\n\r\n    if not file_exists(infile):\r\n        print \"Couldn't find [%s]\" % infile\r\n        return\r\n\r\n    # parse OBJ / MTL files\r\n\r\n    faces, vertices, uvs, normals, materials, mtllib = parse_obj(infile)\r\n\r\n    n_vertices = len(vertices)\r\n    n_faces = len(faces)\r\n\r\n    # align model\r\n\r\n    if ALIGN == \"center\":\r\n        center(vertices)\r\n    elif ALIGN == \"centerxz\":\r\n        centerxz(vertices)\r\n    elif ALIGN == \"bottom\":\r\n        bottom(vertices)\r\n    elif ALIGN == \"top\":\r\n        top(vertices)\r\n\r\n    # generate normals string\r\n\r\n    nnormal = 0\r\n    normals_string = \"\"\r\n    if SHADING == \"smooth\":\r\n        normals_string = \",\".join(generate_normal(n) for n in normals)\r\n        nnormal = len(normals)\r\n\r\n    # extract morph vertices\r\n\r\n    morphTargets = generate_morph_targets(morphfiles, n_vertices, infile)\r\n\r\n    # extract morph colors\r\n\r\n    morphColors, colorFaces, materialColors = generate_morph_colors(colorfiles, n_vertices, n_faces)\r\n\r\n    # generate colors string\r\n\r\n    ncolor = 0\r\n    colors_string = \"\"\r\n\r\n    if len(colorFaces) < len(faces):\r\n        colorFaces = faces\r\n        materialColors = extract_material_colors(materials, mtllib, infile)\r\n\r\n    if BAKE_COLORS:\r\n        colors_string = \",\".join(generate_color_decimal(c) for c in materialColors)\r\n        ncolor = len(materialColors)\r\n\r\n    # generate ascii model string\r\n\r\n    text = TEMPLATE_FILE_ASCII % {\r\n    \"name\"      : get_name(outfile),\r\n    \"fname\"     : os.path.basename(infile),\r\n    \"nvertex\"   : len(vertices),\r\n    \"nface\"     : len(faces),\r\n    \"nuv\"       : len(uvs),\r\n    \"nnormal\"   : nnormal,\r\n    \"ncolor\"    : ncolor,\r\n    \"nmaterial\" : len(materials),\r\n\r\n    \"materials\" : generate_materials_string(materials, mtllib, infile),\r\n\r\n    \"normals\"       : normals_string,\r\n    \"colors\"        : colors_string,\r\n    \"uvs\"           : \",\".join(generate_uv(uv) for uv in uvs),\r\n    \"vertices\"      : \",\".join(generate_vertex(v, TRUNCATE, SCALE) for v in vertices),\r\n\r\n    \"morphTargets\"  : morphTargets,\r\n    \"morphColors\"   : morphColors,\r\n\r\n    \"faces\"     : \",\".join(generate_face(f, fc) for f, fc in zip(faces, colorFaces)),\r\n\r\n    \"scale\"    : SCALE\r\n    }\r\n\r\n    out = open(outfile, \"w\")\r\n    out.write(text)\r\n    out.close()\r\n\r\n    print \"%d vertices, %d faces, %d materials\" % (len(vertices), len(faces), len(materials))\r\n\r\n\r\n# #############################################################################\r\n# API - Binary converter\r\n# #############################################################################\r\ndef dump_materials_to_buffer(faces, buffer):\r\n    for f in faces:\r\n        data = struct.pack('<H',\r\n                            f['material'])\r\n        buffer.append(data)\r\n\r\ndef dump_vertices3_to_buffer(faces, buffer):\r\n    for f in faces:\r\n        vi = f['vertex']\r\n        data = struct.pack('<III',\r\n                            vi[0]-1, vi[1]-1, vi[2]-1)\r\n        buffer.append(data)\r\n\r\ndef dump_vertices4_to_buffer(faces, buffer):\r\n    for f in faces:\r\n        vi = f['vertex']\r\n        data = struct.pack('<IIII',\r\n                            vi[0]-1, vi[1]-1, vi[2]-1, vi[3]-1)\r\n        buffer.append(data)\r\n\r\ndef dump_normals3_to_buffer(faces, buffer):\r\n    for f in faces:\r\n        ni = f['normal']\r\n        data = struct.pack('<III',\r\n                            ni[0]-1, ni[1]-1, ni[2]-1)\r\n        buffer.append(data)\r\n\r\ndef dump_normals4_to_buffer(faces, buffer):\r\n    for f in faces:\r\n        ni = f['normal']\r\n        data = struct.pack('<IIII',\r\n                            ni[0]-1, ni[1]-1, ni[2]-1, ni[3]-1)\r\n        buffer.append(data)\r\n\r\ndef dump_uvs3_to_buffer(faces, buffer):\r\n    for f in faces:\r\n        ui = f['uv']\r\n        data = struct.pack('<III',\r\n                            ui[0]-1, ui[1]-1, ui[2]-1)\r\n        buffer.append(data)\r\n\r\ndef dump_uvs4_to_buffer(faces, buffer):\r\n    for f in faces:\r\n        ui = f['uv']\r\n        data = struct.pack('<IIII',\r\n                            ui[0]-1, ui[1]-1, ui[2]-1, ui[3]-1)\r\n        buffer.append(data)\r\n\r\ndef add_padding(buffer, n):\r\n    if n % 4:\r\n        for i in range(4 - n % 4):\r\n            data = struct.pack('<B', 0)\r\n            buffer.append(data)\r\n\r\ndef convert_binary(infile, outfile):\r\n    \"\"\"Convert infile.obj to outfile.js + outfile.bin\r\n    \"\"\"\r\n\r\n    if not file_exists(infile):\r\n        print \"Couldn't find [%s]\" % infile\r\n        return\r\n\r\n    binfile = get_name(outfile) + \".bin\"\r\n\r\n    faces, vertices, uvs, normals, materials, mtllib = parse_obj(infile)\r\n\r\n    if ALIGN == \"center\":\r\n        center(vertices)\r\n    elif ALIGN == \"centerxz\":\r\n        centerxz(vertices)\r\n    elif ALIGN == \"bottom\":\r\n        bottom(vertices)\r\n    elif ALIGN == \"top\":\r\n        top(vertices)\r\n\r\n    sfaces = sort_faces(faces)\r\n\r\n    if SHADING == \"smooth\":\r\n        nnormals = len(normals)\r\n    else:\r\n        nnormals = 0\r\n\r\n    # ###################\r\n    # generate JS file\r\n    # ###################\r\n\r\n    text = TEMPLATE_FILE_BIN % {\r\n    \"name\"       : get_name(outfile),\r\n\r\n    \"materials\" : generate_materials_string(materials, mtllib, infile),\r\n    \"buffers\"   : binfile,\r\n\r\n    \"fname\"     : os.path.basename(infile),\r\n    \"nvertex\"   : len(vertices),\r\n    \"nface\"     : len(faces),\r\n    \"nmaterial\" : len(materials),\r\n    \"nnormal\"   : nnormals,\r\n    \"nuv\"       : len(uvs)\r\n    }\r\n\r\n    out = open(outfile, \"w\")\r\n    out.write(text)\r\n    out.close()\r\n\r\n    # ###################\r\n    # generate BIN file\r\n    # ###################\r\n\r\n    buffer = []\r\n\r\n    # header\r\n    # ------\r\n    header_bytes  = struct.calcsize('<12s')\r\n    header_bytes += struct.calcsize('<BBBBBBBB')\r\n    header_bytes += struct.calcsize('<IIIIIIIIIII')\r\n\r\n    # signature\r\n    signature = struct.pack('<12s', 'Three.js 003')\r\n\r\n    # metadata (all data is little-endian)\r\n    vertex_coordinate_bytes = 4\r\n    normal_coordinate_bytes = 1\r\n    uv_coordinate_bytes = 4\r\n\r\n    vertex_index_bytes = 4\r\n    normal_index_bytes = 4\r\n    uv_index_bytes = 4\r\n    material_index_bytes = 2\r\n\r\n    # header_bytes            unsigned char   1\r\n\r\n    # vertex_coordinate_bytes unsigned char   1\r\n    # normal_coordinate_bytes unsigned char   1\r\n    # uv_coordinate_bytes     unsigned char   1\r\n\r\n    # vertex_index_bytes      unsigned char   1\r\n    # normal_index_bytes      unsigned char   1\r\n    # uv_index_bytes          unsigned char   1\r\n    # material_index_bytes    unsigned char   1\r\n    bdata = struct.pack('<BBBBBBBB', header_bytes,\r\n                               vertex_coordinate_bytes,\r\n                               normal_coordinate_bytes,\r\n                               uv_coordinate_bytes,\r\n                               vertex_index_bytes,\r\n                               normal_index_bytes,\r\n                               uv_index_bytes,\r\n                               material_index_bytes)\r\n\r\n    ntri_flat = len(sfaces['triangles_flat'])\r\n    ntri_smooth = len(sfaces['triangles_smooth'])\r\n    ntri_flat_uv = len(sfaces['triangles_flat_uv'])\r\n    ntri_smooth_uv = len(sfaces['triangles_smooth_uv'])\r\n\r\n    nquad_flat = len(sfaces['quads_flat'])\r\n    nquad_smooth = len(sfaces['quads_smooth'])\r\n    nquad_flat_uv = len(sfaces['quads_flat_uv'])\r\n    nquad_smooth_uv = len(sfaces['quads_smooth_uv'])\r\n\r\n    # nvertices       unsigned int    4\r\n    # nnormals        unsigned int    4\r\n    # nuvs            unsigned int    4\r\n\r\n    # ntri_flat       unsigned int    4\r\n    # ntri_smooth     unsigned int    4\r\n    # ntri_flat_uv    unsigned int    4\r\n    # ntri_smooth_uv  unsigned int    4\r\n\r\n    # nquad_flat      unsigned int    4\r\n    # nquad_smooth    unsigned int    4\r\n    # nquad_flat_uv   unsigned int    4\r\n    # nquad_smooth_uv unsigned int    4\r\n    ndata = struct.pack('<IIIIIIIIIII', len(vertices),\r\n                               nnormals,\r\n                               len(uvs),\r\n                               ntri_flat,\r\n                               ntri_smooth,\r\n                               ntri_flat_uv,\r\n                               ntri_smooth_uv,\r\n                               nquad_flat,\r\n                               nquad_smooth,\r\n                               nquad_flat_uv,\r\n                               nquad_smooth_uv)\r\n    buffer.append(signature)\r\n    buffer.append(bdata)\r\n    buffer.append(ndata)\r\n\r\n    # 1. vertices\r\n    # ------------\r\n    # x float   4\r\n    # y float   4\r\n    # z float   4\r\n    for v in vertices:\r\n        data = struct.pack('<fff', v[0], v[1], v[2])\r\n        buffer.append(data)\r\n\r\n    # 2. normals\r\n    # ---------------\r\n    # x signed char 1\r\n    # y signed char 1\r\n    # z signed char 1\r\n    if SHADING == \"smooth\":\r\n        for n in normals:\r\n            normalize(n)\r\n            data = struct.pack('<bbb', math.floor(n[0]*127+0.5),\r\n                                       math.floor(n[1]*127+0.5),\r\n                                       math.floor(n[2]*127+0.5))\r\n            buffer.append(data)\r\n\r\n        add_padding(buffer, nnormals * 3)\r\n\r\n    # 3. uvs\r\n    # -----------\r\n    # u float   4\r\n    # v float   4\r\n    for uv in uvs:\r\n        data = struct.pack('<ff', uv[0], uv[1])\r\n        buffer.append(data)\r\n\r\n    # padding\r\n    #data = struct.pack('<BB', 0, 0)\r\n    #buffer.append(data)\r\n\r\n    # 4. flat triangles (vertices + materials)\r\n    # ------------------\r\n    # a unsigned int   4\r\n    # b unsigned int   4\r\n    # c unsigned int   4\r\n    # ------------------\r\n    # m unsigned short 2\r\n\r\n    dump_vertices3_to_buffer(sfaces['triangles_flat'], buffer)\r\n\r\n    dump_materials_to_buffer(sfaces['triangles_flat'], buffer)\r\n    add_padding(buffer, ntri_flat * 2)\r\n\r\n    # 5. smooth triangles (vertices + materials + normals)\r\n    # -------------------\r\n    # a  unsigned int   4\r\n    # b  unsigned int   4\r\n    # c  unsigned int   4\r\n    # -------------------\r\n    # na unsigned int   4\r\n    # nb unsigned int   4\r\n    # nc unsigned int   4\r\n    # -------------------\r\n    # m  unsigned short 2\r\n\r\n    dump_vertices3_to_buffer(sfaces['triangles_smooth'], buffer)\r\n    dump_normals3_to_buffer(sfaces['triangles_smooth'], buffer)\r\n\r\n    dump_materials_to_buffer(sfaces['triangles_smooth'], buffer)\r\n    add_padding(buffer, ntri_smooth * 2)\r\n\r\n    # 6. flat triangles uv (vertices + materials + uvs)\r\n    # --------------------\r\n    # a  unsigned int    4\r\n    # b  unsigned int    4\r\n    # c  unsigned int    4\r\n    # --------------------\r\n    # ua unsigned int    4\r\n    # ub unsigned int    4\r\n    # uc unsigned int    4\r\n    # --------------------\r\n    # m  unsigned short  2\r\n\r\n    dump_vertices3_to_buffer(sfaces['triangles_flat_uv'], buffer)\r\n    dump_uvs3_to_buffer(sfaces['triangles_flat_uv'], buffer)\r\n\r\n    dump_materials_to_buffer(sfaces['triangles_flat_uv'], buffer)\r\n    add_padding(buffer, ntri_flat_uv * 2)\r\n\r\n    # 7. smooth triangles uv (vertices + materials + normals + uvs)\r\n    # ----------------------\r\n    # a  unsigned int    4\r\n    # b  unsigned int    4\r\n    # c  unsigned int    4\r\n    # --------------------\r\n    # na unsigned int    4\r\n    # nb unsigned int    4\r\n    # nc unsigned int    4\r\n    # --------------------\r\n    # ua unsigned int    4\r\n    # ub unsigned int    4\r\n    # uc unsigned int    4\r\n    # --------------------\r\n    # m  unsigned short  2\r\n\r\n    dump_vertices3_to_buffer(sfaces['triangles_smooth_uv'], buffer)\r\n    dump_normals3_to_buffer(sfaces['triangles_smooth_uv'], buffer)\r\n    dump_uvs3_to_buffer(sfaces['triangles_smooth_uv'], buffer)\r\n\r\n    dump_materials_to_buffer(sfaces['triangles_smooth_uv'], buffer)\r\n    add_padding(buffer, ntri_smooth_uv * 2)\r\n\r\n    # 8. flat quads (vertices + materials)\r\n    # ------------------\r\n    # a unsigned int   4\r\n    # b unsigned int   4\r\n    # c unsigned int   4\r\n    # d unsigned int   4\r\n    # --------------------\r\n    # m unsigned short 2\r\n\r\n    dump_vertices4_to_buffer(sfaces['quads_flat'], buffer)\r\n\r\n    dump_materials_to_buffer(sfaces['quads_flat'], buffer)\r\n    add_padding(buffer, nquad_flat * 2)\r\n\r\n    # 9. smooth quads (vertices + materials + normals)\r\n    # -------------------\r\n    # a  unsigned int   4\r\n    # b  unsigned int   4\r\n    # c  unsigned int   4\r\n    # d  unsigned int   4\r\n    # --------------------\r\n    # na unsigned int   4\r\n    # nb unsigned int   4\r\n    # nc unsigned int   4\r\n    # nd unsigned int   4\r\n    # --------------------\r\n    # m  unsigned short 2\r\n\r\n    dump_vertices4_to_buffer(sfaces['quads_smooth'], buffer)\r\n    dump_normals4_to_buffer(sfaces['quads_smooth'], buffer)\r\n\r\n    dump_materials_to_buffer(sfaces['quads_smooth'], buffer)\r\n    add_padding(buffer, nquad_smooth * 2)\r\n\r\n    # 10. flat quads uv (vertices + materials + uvs)\r\n    # ------------------\r\n    # a unsigned int   4\r\n    # b unsigned int   4\r\n    # c unsigned int   4\r\n    # d unsigned int   4\r\n    # --------------------\r\n    # ua unsigned int  4\r\n    # ub unsigned int  4\r\n    # uc unsigned int  4\r\n    # ud unsigned int  4\r\n    # --------------------\r\n    # m unsigned short 2\r\n\r\n    dump_vertices4_to_buffer(sfaces['quads_flat_uv'], buffer)\r\n    dump_uvs4_to_buffer(sfaces['quads_flat_uv'], buffer)\r\n\r\n    dump_materials_to_buffer(sfaces['quads_flat_uv'], buffer)\r\n    add_padding(buffer, nquad_flat_uv * 2)\r\n\r\n    # 11. smooth quads uv\r\n    # -------------------\r\n    # a  unsigned int   4\r\n    # b  unsigned int   4\r\n    # c  unsigned int   4\r\n    # d  unsigned int   4\r\n    # --------------------\r\n    # na unsigned int   4\r\n    # nb unsigned int   4\r\n    # nc unsigned int   4\r\n    # nd unsigned int   4\r\n    # --------------------\r\n    # ua unsigned int   4\r\n    # ub unsigned int   4\r\n    # uc unsigned int   4\r\n    # ud unsigned int   4\r\n    # --------------------\r\n    # m  unsigned short 2\r\n\r\n    dump_vertices4_to_buffer(sfaces['quads_smooth_uv'], buffer)\r\n    dump_normals4_to_buffer(sfaces['quads_smooth_uv'], buffer)\r\n    dump_uvs4_to_buffer(sfaces['quads_smooth_uv'], buffer)\r\n\r\n    dump_materials_to_buffer(sfaces['quads_smooth_uv'], buffer)\r\n    add_padding(buffer, nquad_smooth_uv * 2)\r\n\r\n    path = os.path.dirname(outfile)\r\n    fname = os.path.join(path, binfile)\r\n\r\n    out = open(fname, \"wb\")\r\n    out.write(\"\".join(buffer))\r\n    out.close()\r\n\r\n# #############################################################################\r\n# Helpers\r\n# #############################################################################\r\ndef usage():\r\n    print \"Usage: %s -i filename.obj -o filename.js [-m morphfiles*.obj] [-c morphcolors*.obj] [-a center|top|bottom] [-s flat|smooth] [-t binary|ascii] [-d invert|normal]\" % os.path.basename(sys.argv[0])\r\n\r\n# #####################################################\r\n# Main\r\n# #####################################################\r\nif __name__ == \"__main__\":\r\n\r\n    # get parameters from the command line\r\n    try:\r\n        opts, args = getopt.getopt(sys.argv[1:], \"hbi:m:c:b:o:a:s:t:d:x:f:\", [\"help\", \"bakecolors\", \"input=\", \"morphs=\", \"colors=\", \"output=\", \"align=\", \"shading=\", \"type=\", \"dissolve=\", \"truncatescale=\", \"framestep=\"])\r\n\r\n    except getopt.GetoptError:\r\n        usage()\r\n        sys.exit(2)\r\n\r\n    infile = outfile = \"\"\r\n    morphfiles = \"\"\r\n    colorfiles = \"\"\r\n\r\n    for o, a in opts:\r\n        if o in (\"-h\", \"--help\"):\r\n            usage()\r\n            sys.exit()\r\n\r\n        elif o in (\"-i\", \"--input\"):\r\n            infile = a\r\n\r\n        elif o in (\"-m\", \"--morphs\"):\r\n            morphfiles = a\r\n\r\n        elif o in (\"-c\", \"--colors\"):\r\n            colorfiles = a\r\n\r\n        elif o in (\"-o\", \"--output\"):\r\n            outfile = a\r\n\r\n        elif o in (\"-a\", \"--align\"):\r\n            if a in (\"top\", \"bottom\", \"center\", \"centerxz\", \"none\"):\r\n                ALIGN = a\r\n\r\n        elif o in (\"-s\", \"--shading\"):\r\n            if a in (\"flat\", \"smooth\"):\r\n                SHADING = a\r\n\r\n        elif o in (\"-t\", \"--type\"):\r\n            if a in (\"binary\", \"ascii\"):\r\n                TYPE = a\r\n\r\n        elif o in (\"-d\", \"--dissolve\"):\r\n            if a in (\"normal\", \"invert\"):\r\n                TRANSPARENCY = a\r\n\r\n        elif o in (\"-b\", \"--bakecolors\"):\r\n            BAKE_COLORS = True\r\n\r\n        elif o in (\"-x\", \"--truncatescale\"):\r\n            TRUNCATE = True\r\n            SCALE = float(a)\r\n\r\n        elif o in (\"-f\", \"--framestep\"):\r\n            FRAMESTEP = int(a)\r\n\r\n    if infile == \"\" or outfile == \"\":\r\n        usage()\r\n        sys.exit(2)\r\n\r\n    print \"Converting [%s] into [%s] ...\" % (infile, outfile)\r\n\r\n    if morphfiles:\r\n        print \"Morphs [%s]\" % morphfiles\r\n\r\n    if colorfiles:\r\n        print \"Colors [%s]\" % colorfiles\r\n\r\n    if TYPE == \"ascii\":\r\n        convert_ascii(infile, morphfiles, colorfiles, outfile)\r\n    elif TYPE == \"binary\":\r\n        convert_binary(infile, outfile)"]],"start1":0,"start2":0,"length1":0,"length2":49052}]],"length":49052,"saved":false}
{"ts":1350874681867,"patch":[[{"diffs":[[0,"vert_binary(infile, outfile)"],[1,"\r\n        "]],"start1":49024,"start2":49024,"length1":28,"length2":38}]],"length":49062,"saved":false}
